这个报错的关键信息其实很明确：

Cannot read properties of null (reading '$emitter')
setInstanceEmitter2 -> rootConfig2 -> $setup2 -> runtime-core.esm-bundler.js

它说明 某段代码想从“当前组件实例”上拿 $emitter，但“当前组件实例”为 null。在 Vue3 里，出现这种情况通常只有两大类根因（monorepo + pnpm 场景里第二类特别高发）：

⸻

结论 1（最常见）：你在 “没有组件实例的上下文” 调用了依赖 getCurrentInstance() 的逻辑

比如把类似下面的东西放在了 setup() 外面、模块顶层、或者在路由文件/工具文件加载时就执行了：

import { getCurrentInstance } from 'vue'
const ins = getCurrentInstance() // 这里会是 null（不在组件 setup 执行期间）

而你的 setInstanceEmitter2 / rootConfig2 看起来就像某个库在初始化时去做 getCurrentInstance() 或去读 instance.proxy.$emitter。

✅ 排查方式（不用猜）
	•	打开报错里提到的 index.js（通常在 devtools Sources 里能点到）
	•	搜索 getCurrentInstance、$emitter、globalProperties
	•	看它是不是在模块加载时就执行，而不是在 setup() 里执行。

✅ 修复方式
	•	确保 “安装/注册 emitter 插件” 发生在 main.ts 里 app.mount 之前，例如：

const app = createApp(App)
// app.config.globalProperties.$emitter = ...
app.use(EmitterPlugin)
app.mount('#app')

	•	任何依赖实例的逻辑必须放在组件 setup() 内部（或生命周期内）再调用。

⸻

结论 2（pnpm workspace 超高发）：你项目里存在 两份 Vue（或两份 runtime）

这会导致一个非常诡异的现象：
	•	你的组件是用 Vue A 创建的实例
	•	但某个依赖（比如 emitter 相关库）导入的是 Vue B 的 getCurrentInstance()
	•	在 Vue B 看来“当前实例上下文根本不存在”，于是 getCurrentInstance() 返回 null
	•	接着就出现你看到的：读取 $emitter 报 null

这也是为什么：拷贝出去单独装依赖能跑，但在 pnpm workspace 下容易炸（pnpm 的隔离+软链接更容易让某些依赖各自带一份 vue）。

✅ 一步确认是不是这个原因（强烈建议你先做这个）
在仓库根目录执行：

pnpm -F vue3-web1 why vue
pnpm -F vue3-web1 list vue --depth 10

你要看的不是“有没有 vue”，而是 有没有出现多个版本 / 多个安装路径（输出里如果出现不止一个 vue@x.y.z，基本就坐实了）。

✅ 修复手段（按推荐顺序）

A. 统一 Vue 版本（最有效）

在根 package.json 用 pnpm overrides 强行统一（别删 overrides，反而要用它）：

{
  "pnpm": {
    "overrides": {
      "vue": "3.4.x",
      "@vue/runtime-core": "3.4.x",
      "@vue/runtime-dom": "3.4.x",
      "@vue/shared": "3.4.x"
    }
  }
}

然后重新安装：

pnpm -w install

B. webpack 强制只解析到同一份 Vue（很关键）

在 vue3-web1/webpack.config.js 里加（示例）：

const path = require('path')

module.exports = {
  resolve: {
    alias: {
      vue$: path.resolve(__dirname, '../../node_modules/vue/dist/vue.esm-bundler.js'),
      vue: path.resolve(__dirname, '../../node_modules/vue')
    },
    symlinks: false
  }
}

symlinks: false 这一条在 monorepo/软链接场景里经常能避免“解析到另一份依赖”。

C. 如果你有自家 workspace 包（哪怕现在只有一个包，也建议记住）

任何内部包都不要把 vue 写成 dependencies，而应当写成 peerDependencies（否则很容易带出第二份 vue）。

⸻

我建议你现在立刻做的 3 个动作（最省时间）
	1.	跑：pnpm -F vue3-web1 why vue（看是否多份 vue）
	2.	把报错对应的 index.js 顶部几行贴出来（尤其是它属于哪个包：路径里通常有 node_modules/xxx/index.js）
	3.	告诉我你 $emitter 用的是哪个库（比如 mitt / vue3-eventbus / 自己封装的 emitter 插件？）

只要你把 index.js 的文件路径贴一下（例如 .../node_modules/某某库/dist/index.js），我就能直接告诉你：
	•	是“库用法不对（不在 setup/app.use 时机）”，还是
	•	是“重复 Vue 导致 getCurrentInstance 为 null”，以及具体该怎么改 webpack alias / overrides。




    ```
      const newVueText = vueText.replace(
    scriptBlock.full,
    () => {
      return `<script>\n${newScript.trim()}\n</script>`;
    }
  );
    ```